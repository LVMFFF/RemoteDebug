## 跳转岛机制
当前补丁机制为：修改函数入口指令为跳转指令，且为短跳转，原因是当函数过短时（可能只包含一条指令），使用长跳转会覆盖后续指令。当补丁函数与原始函数之间的地址间隔过大时（大于短跳转指令范围），短跳转指令无法直接跳到补丁函数入口与，需要通过中转，这就是跳转岛基本机制。下面为跳转岛基本实现原理：

+----------------+       +----------------+       +----------------+
| 原始函数入口   | ----> |   跳转岛       | ----> | 补丁函数       |
| (短跳转指令)   |       | (长跳转指令 +  |       |                |
|                |       |  原始入口代码) |       |                |
+----------------+       +----------------+       +----------------+

## 跳转岛实现
主要有两种情况：一：目标动态库中预留跳转岛时，可以直接使用动态库空间中的跳转岛，此中方式实现简单，前提是需要在编译时添加跳转岛session;
二：目标动态库没有预留跳转岛时直接打补丁，此种情况可能失败，具体取决于当前补丁附件有无空间用于二次跳转，也就是补丁程序能否自动寻找到空间用于实现跳转岛；

### 目标程序预先保留跳转岛 session
实现：在编译动态库时，修改编译程序，添加 